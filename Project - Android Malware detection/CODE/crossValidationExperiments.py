import projectFunctions
#from sklearn.model_selection import KFold
import copy
import percepFunctions
import numpy as np
#import matplotlib.pyplot as plt

#Simple Perceptron
def simplePerceptron_cvRate(train_matrix, train_actual_labels, rateRange, num_folds):
    av_accuracy_list = []
    av_f1_list = []
    for rate in rateRange:
        print 'rate: ', rate
        '''
        ###############
        kf = KFold(n_splits=5)
        temp_train_Matrix = copy.deepcopy(train_matrix)
        temp_train_Labels = copy.deepcopy(train_actual_labels)
        count = 0
        accuracy_list = []
        for train_indices, test_indices in kf.split(temp_train_Matrix):
            temp_test_Matrix = []
            temp_test_Labels = []
            for test_indx in test_indices:
                count +=1
                #print 'count: ', count
                temp_test_Matrix.append(temp_train_Matrix[test_indx-count])
                temp_test_Labels.append(temp_train_Labels[test_indx-count])
                np.delete(temp_train_Matrix, test_indx-count, 0)
                np.delete(temp_train_Labels, test_indx-count, 0)

        ################
        '''
        accuracy_list = []
        f1_list = []
        training_lab = copy.deepcopy(train_actual_labels)
        training_lab = training_lab.tolist()
        training_mat = copy.deepcopy(train_matrix)
        training_mat = training_mat.tolist()
        subset_size = len(training_mat)/num_folds
        for i in range(num_folds):
            #
            if i == num_folds-1:
                temp_test_Matrix = training_mat[(i)*subset_size:]
                temp_train_Matrix = training_mat[0:][:i*subset_size]
                #
                temp_test_Labels = training_lab[(i)*subset_size:]
                temp_train_Labels = training_lab[0:][:i*subset_size]
            else:
                temp_test_Matrix = training_mat[i*subset_size:][:subset_size]
                #temp_train_Matrix =np.append(training_mat[:i * subset_size],training_mat[(i + 1) * subset_size:])
                temp_train_Matrix = training_mat[:i*subset_size] + training_mat[(i+1)*subset_size:]
                #
                temp_test_Labels = training_lab[i*subset_size:][:subset_size]
                temp_train_Labels = training_lab[:i*subset_size] + training_lab[(i+1)*subset_size:]
            # Training
            w_train, numUpdates_simpleP = percepFunctions.weightedPerceptron(temp_train_Matrix, temp_train_Labels,'zeros', rate)
            predicted_labels = projectFunctions.prediction_Perceptron(temp_test_Matrix, temp_test_Labels, w_train)
            # Metric
            #test_accuracy = projectFunctions.accuracyMETRIC(temp_test_Labels, predicted_labels)
            test_f1 = projectFunctions.f1METRIC(temp_test_Labels, predicted_labels)
            #accuracy_list.append(test_accuracy)
            f1_list.append(test_f1)
        #av_accuracy = np.mean(accuracy_list)
        av_f1 = np.mean(f1_list)
        #av_accuracy_list.append(av_accuracy)
        av_f1_list.append(av_f1)

        #print av_accuracy
        print av_f1
    #best_accuracy = max(av_accuracy_list)
    best_f1 = max(av_f1_list)
    #max_index = av_accuracy_list.index(best_accuracy)
    max_index = av_f1_list.index(best_f1)
    best_rate = rateRange[max_index]
    #
    #line, = plt.plot(rateRange, av_accuracy_list)
    line, = plt.plot(rateRange, av_f1_list)
    plt.xlabel('Learning Rate')
    #plt.ylabel('Accuracy')
    #plt.title('Accuracy v/s Learning Rate, for Simple perceptron')
    plt.ylabel('F1 score')
    plt.title('F1 score v/s Learning Rate, for Simple Weighted perceptron')
    plt.grid(True)
    plt.show()
    #return best_accuracy, best_rate, av_accuracy_list
    return best_f1, best_rate, av_f1_list

def marginPerceptron_cvRate(train_matrix, train_actual_labels, rateRange, num_folds):
    av_accuracy_list = []
    for rate in rateRange:
        print 'rate: ', rate
        accuracy_list = []
        training_lab = copy.deepcopy(train_actual_labels)
        training_lab = training_lab.tolist()
        training_mat = copy.deepcopy(train_matrix)
        training_mat = training_mat.tolist()
        subset_size = len(training_mat)/num_folds
        for i in range(num_folds):
            #
            if i == num_folds-1:
                temp_test_Matrix = training_mat[(i)*subset_size:]
                temp_train_Matrix = training_mat[0:][:i*subset_size]
                #
                temp_test_Labels = training_lab[(i)*subset_size:]
                temp_train_Labels = training_lab[0:][:i*subset_size]
            else:
                temp_test_Matrix = training_mat[i*subset_size:][:subset_size]
                #temp_train_Matrix =np.append(training_mat[:i * subset_size],training_mat[(i + 1) * subset_size:])
                temp_train_Matrix = training_mat[:i*subset_size] + training_mat[(i+1)*subset_size:]
                #
                temp_test_Labels = training_lab[i*subset_size:][:subset_size]
                temp_train_Labels = training_lab[:i*subset_size] + training_lab[(i+1)*subset_size:]


            # Training
            w_train, numUpdates_simpleP = percepFunctions.marginPerceptron(temp_train_Matrix, temp_train_Labels,'zeros',1, rate)
            #print 'weight %s is %f' %(i,max(w_train))
            predicted_labels = projectFunctions.prediction_Perceptron(temp_test_Matrix, temp_test_Labels, w_train)
            # Metric
            #test_accuracy, test_f1_score = projectFunctions.accuracyMETRIC(temp_test_Labels, predicted_labels)
            test_accuracy = projectFunctions.accuracyMETRIC(temp_test_Labels, predicted_labels)
            accuracy_list.append(test_accuracy)
        av_accuracy = np.mean(accuracy_list)
        av_accuracy_list.append(av_accuracy)
        print av_accuracy
    best_accuracy = max(av_accuracy_list)
    max_index = av_accuracy_list.index(best_accuracy)
    best_rate = rateRange[max_index]
    #
    line, = plt.plot(rateRange, av_accuracy_list)
    plt.xlabel('Learning Rate')
    plt.ylabel('Accuracy')
    plt.title('Accuracy v/s Learning Rate, for Simple perceptron')
    plt.grid(True)
    plt.show()
    return best_accuracy, best_rate, av_accuracy_list

def simplePerceptron_cvWeight(train_matrix, train_actual_labels, weightRange, num_folds):
    av_accuracy_list = []
    for weight in weightRange:
        print 'weight: ', weight
        '''
        ###############
        kf = KFold(n_splits=5)
        temp_train_Matrix = copy.deepcopy(train_matrix)
        temp_train_Labels = copy.deepcopy(train_actual_labels)
        count = 0
        accuracy_list = []
        for train_indices, test_indices in kf.split(temp_train_Matrix):
            temp_test_Matrix = []
            temp_test_Labels = []
            for test_indx in test_indices:
                count +=1
                #print 'count: ', count
                temp_test_Matrix.append(temp_train_Matrix[test_indx-count])
                temp_test_Labels.append(temp_train_Labels[test_indx-count])
                np.delete(temp_train_Matrix, test_indx-count, 0)
                np.delete(temp_train_Labels, test_indx-count, 0)

        ################
        '''
        accuracy_list = []
        training_lab = copy.deepcopy(train_actual_labels)
        training_lab = training_lab.tolist()
        training_mat = copy.deepcopy(train_matrix)
        training_mat = training_mat.tolist()
        subset_size = len(training_mat)/num_folds
        for i in range(num_folds):
            #
            if i == num_folds-1:
                temp_test_Matrix = training_mat[(i)*subset_size:]
                temp_train_Matrix = training_mat[0:][:i*subset_size]
                #
                temp_test_Labels = training_lab[(i)*subset_size:]
                temp_train_Labels = training_lab[0:][:i*subset_size]
                continue
            temp_test_Matrix = training_mat[i*subset_size:][:subset_size]
            #temp_train_Matrix =np.append(training_mat[:i * subset_size],training_mat[(i + 1) * subset_size:])
            temp_train_Matrix = training_mat[:i*subset_size] + training_mat[(i+1)*subset_size:]
            #
            temp_test_Labels = training_lab[i*subset_size:][:subset_size]
            temp_train_Labels = training_lab[:i*subset_size] + training_lab[(i+1)*subset_size:]
            #

            # Training
            w_train, numUpdates_simpleP = percepFunctions.simplePerceptron(temp_train_Matrix, temp_train_Labels,weight, 1)
            # Prediction on eval.anon
            predicted_labels = projectFunctions.prediction_Perceptron(temp_test_Matrix, temp_test_Labels, w_train)
            # Metric
            #test_accuracy, test_f1_score = projectFunctions.accuracyMETRIC(temp_test_Labels, predicted_labels)
            test_accuracy = projectFunctions.accuracyMETRIC(temp_test_Labels, predicted_labels)
            accuracy_list.append(test_accuracy)
        av_accuracy = np.mean(accuracy_list)
        av_accuracy_list.append(av_accuracy)
        print av_accuracy
    best_accuracy = max(av_accuracy_list)
    max_index = av_accuracy_list.index(best_accuracy)
    best_weight = weightRange[max_index]
    #
    line, = plt.plot(weightRange, av_accuracy_list)
    plt.xlabel('initialization weight')
    plt.ylabel('Accuracy')
    plt.title('Accuracy v/s Learning weight, for Simple perceptron')
    plt.grid(True)
    plt.show()
    return best_accuracy, weight, av_accuracy_list