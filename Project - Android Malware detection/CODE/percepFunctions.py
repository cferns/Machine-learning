from __future__ import division
import numpy as np
import random
import copy
import csv
#from sklearn.datasets import load_svmlight_file
import projectFunctions
from sklearn.utils import shuffle
#scikit learn libraries are not used even though the code lines are typed here

def readFile(filepath):
    csrMatrix, labelsTemp = load_svmlight_file(filepath)
    #following line is to convert folat64 to int32; not required
    labels = np.array(labelsTemp)
    matRix = csrMatrix.toarray()
    #rowsM, colsM = matRix.shape
    for i in range(len(labels)):
        labels[i] = 2*labels[i]-1
    return matRix, labels

def readFile_multi(filepath, features_case):
    file = open(filepath, 'rb')
    data = csv.reader(file, delimiter=' ')
    matrix = [row for row in data]
    for mDat in matrix:
        if mDat[-1] == '':
            del mDat[-1]
    labels = []
    Totalmatrix = []
    maxFtrCol = 0
    for i in range(len(matrix)):
        lineData = csv.reader(matrix[i], delimiter=':')
        rowmatrix = [row for row in lineData]
        T2 = [map(int, x) for x in rowmatrix]
        temp = 2*(T2[0][0])-1
        labels.append(temp)
        #if T2[1][0] == 0:
            #startWzero = 'yes'
        for j in range(1, len(T2)):
            tempo = T2[j][0]
            if ((tempo) > maxFtrCol):
                maxFtrCol = tempo
        Totalmatrix.append(T2)

    if features_case == 'w':
        finalMatrix = np.zeros((len(matrix), maxFtrCol))
        for i in range(len(Totalmatrix)):
            for j in range(1, (len(Totalmatrix[i]))):
                finalMatrix[i][Totalmatrix[i][j][0] - 1] = Totalmatrix[i][j][1]

    elif features_case == '01':
        finalMatrix = np.zeros((len(matrix), maxFtrCol))
        for i in range(len(Totalmatrix)):
            for j in range(1, (len(Totalmatrix[i]))):
                finalMatrix[i][Totalmatrix[i][j][0] - 1] = 1

    labels = np.asarray(labels)
    return finalMatrix, labels

def shuffleFunction(a, b):
    c = np.c_[a.reshape(len(a), -1), b.reshape(len(b), -1)]
    np.random.shuffle(c)
    a2 = c[:, :a.size // len(a)].reshape(a.shape)
    b2 = c[:, a.size // len(a):].reshape(b.shape)
    return a2, b2

def weightFunction(weightCondition, cols):
    if weightCondition is 'zeros':
        w = np.zeros(cols+1, dtype=np.float)
    elif weightCondition is 'random':
        w = np.ones(cols+1, dtype=np.float)*random.gauss(0, 0.01)
    elif type(weightCondition) is str:
        val = float(weightCondition)
        w = np.ones(cols + 1, dtype=np.float) * val
    elif type(weightCondition) is not str:
        w = weightCondition
    return w

def simplePerceptron(matRix, labels, weightCondition, r):
    #rows, cols = matRix.shape
    rows = len(matRix)
    cols = len(matRix[0])
    numUpdates = 0
    w = weightFunction(weightCondition, cols)
    for r_ind in range(rows):
        #Perceptron decision
        currExample = np.append([1], matRix[r_ind])
        y_pred = np.sign(np.dot(w,currExample))
        y_actual = labels[r_ind]
        #Decision
        if y_pred*y_actual <= 0:
           # Update
            w = w + r*y_actual*currExample
            numUpdates += 1
    return w, numUpdates

def weightedPerceptron(matRix, labels, weightCondition, r):
    rows = len(matRix)
    cols = len(matRix[0])
    numUpdates = 0
    count = 0
    counter = []
    w_all = []
    count_sum = 0
    w = weightFunction(weightCondition, cols)
    w_sum = np.zeros(len(w))
    for r_ind in range(rows):
        #prediction
        currExample = np.append([1], matRix[r_ind])
        y_pred = np.sign(np.dot(w,currExample))
        y_actual = labels[r_ind]
        #Decision
        if y_pred*y_actual <= 0:
            # Update
            #counter.append(count)
            #w_all.append(w)
            w_sum = w_sum+w*count
            count_sum = count_sum + count
            w = w + r*y_actual*currExample
            numUpdates += 1
            count = 0
        count += 1
    #w_all.append(w)
    #counter.append(count)
    w_sum = w_sum + w * count
    count_sum = count_sum + count
    w = w_sum/count_sum
    return w, numUpdates

def marginPerceptron(matRix, labels, weightCondition, r, margin):
    rows = len(matRix)
    cols = len(matRix[0])
    numUpdates = 0
    w = weightFunction(weightCondition, cols)
    for r_ind in range(rows):
        #Perceptron decision
        currExample = np.append([1], matRix[r_ind])
        y_pred = np.sign(np.dot(w,currExample))
        y_actual = labels[r_ind]
        #Decision
        if y_pred*y_actual <= margin:
           # Update
            w = w + r*y_actual*currExample
            numUpdates += 1
    return w, numUpdates

def agrresiveMarginPerceptron(matRix, labels, weightCondition, r, margin):
    rows = len(matRix)
    cols = len(matRix[0])
    numUpdates = 0
    w = weightFunction(weightCondition, cols)
    for r_ind in range(rows):
        #Perceptron decision
        currExample = np.append([1], matRix[r_ind])
        y_pred = np.sign(np.dot(w,currExample))
        y_actual = labels[r_ind]
        #Decision
        if y_pred*y_actual <= margin:
            # Update
            n = (margin - y_pred*y_actual)/(np.dot(currExample,currExample)+1)
            w = w + n*y_actual*currExample
            numUpdates += 1
    return w, numUpdates

def WeightedAgrresiveMarginPerceptron(matRix, labels, weightCondition, r, margin):
    rows = len(matRix)
    cols = len(matRix[0])
    count = 0
    numUpdates = 0
    count_sum = 0
    w = weightFunction(weightCondition, cols)
    w_sum = np.zeros(len(w))
    for r_ind in range(rows):
        #Perceptron decision
        currExample = np.append([1], matRix[r_ind])
        y_pred = np.sign(np.dot(w,currExample))
        y_actual = labels[r_ind]
        #Decision
        if y_pred*y_actual <= margin:
            # Update
            w_sum = w_sum+w*count
            count_sum = count_sum + count
            n = (margin - y_pred*y_actual)/(np.dot(currExample,currExample)+1)
            w = w + n*y_actual*currExample
            numUpdates += 1
            count = 0
        count += 1
    w_sum = w_sum + w * count
    count_sum = count_sum + count
    w = w_sum/count_sum
    return w, numUpdates

def accuracyFunc(matRix, labels, w):
    rows, cols = matRix.shape
    if (w.size-1)!= cols:
        num_extra_features = cols - (w.size - 1)
        for e in range(num_extra_features):
            w = np.append(w,[0])
    errorCount = 0
    for r_ind in range(rows):
        currExample = np.append([1], matRix[r_ind])
        y_pred = np.sign(np.dot(w, currExample))
        y_actual = labels[r_ind]
        #Decision
        if y_pred != y_actual:
            errorCount += 1
    accuracy = ((rows - errorCount)/rows)*100
    return accuracy

def algoFORepochs(numEpochs, trainMatrix, trainLabels, testMatrix, testLabels, algo_type, learningRate, initialWcondition, margin = None):
    #for info ARRAY

    infoList = []
    temp_list = []
    temp_list.append('shuffleTYPE')
    temp_list.append('num of Epochs')
    temp_list.append('acc_train')
    temp_list.append('f1_train')
    temp_list.append('acc_test')
    temp_list.append('f1_test')
    temp_list.append('weights')
    #
    infoList.append(temp_list)

    tempTrainMatrix = copy.deepcopy(trainMatrix)
    tempTrainLabels = copy.deepcopy(trainLabels)


    best_w = np.zeros(361)
    best_train_acc = 0
    best_f1_train = 0
    av_count = 1
    #for noYesShuffle in range(2):
    total_numUpdates = 0
    w = 0
    for e_ind in range(numEpochs):
        #shuffling section start
        if e_ind == 0:
            shuffleTYPE = 'no shuffle'
            trainingExMat = trainMatrix
            trainExLabels = trainLabels
        else:
            shuffleTYPE = 'with shuffle'
            if e_ind == 0:
                trainingExMat = trainMatrix
                trainExLabels = trainLabels
            else:
                trainingExMat, trainExLabels = shuffle(tempTrainMatrix, tempTrainLabels, random_state=0)
                #trainingExMat, trainExLabels = shuffleFunction(tempTrainMatrix, tempTrainLabels)
                tempTrainMatrix = trainingExMat
                tempTrainLabels = trainExLabels
        # shuffling section end
        if e_ind == 0:
            weightCondition = initialWcondition
        else:
            weightCondition = w
        if algo_type == 'simple':
            w, numUpdates = simplePerceptron(trainingExMat, trainExLabels, weightCondition, learningRate)
        elif algo_type == 'margin':
            w, numUpdates = marginPerceptron(trainingExMat, trainExLabels, weightCondition, learningRate, margin)
        elif algo_type == 'aggressive':
            w, numUpdates = agrresiveMarginPerceptron(trainingExMat, trainExLabels, weightCondition, learningRate, margin)
        elif algo_type == 'weightedAggressive':
            w, numUpdates = WeightedAgrresiveMarginPerceptron(trainingExMat, trainExLabels, weightCondition, learningRate, margin)
        elif algo_type == 'weightedSimple':
            w, numUpdates = weightedPerceptron(trainingExMat, trainExLabels, weightCondition, learningRate)
        elif algo_type == 'winnow':
            w, numUpdates = winnowFunctions.simpleWinnow(trainingExMat, trainExLabels, 'ones', 2)
        total_numUpdates += numUpdates

        if algo_type == 'winnow':
            train_pred_labels = projectFunctions.prediction_Winnow(trainMatrix, trainLabels, w)
            acc_train = projectFunctions.accuracyMETRIC(trainLabels, train_pred_labels)
            test_pred_labels = projectFunctions.prediction_Winnow(testMatrix, testLabels, w)
            acc_test = projectFunctions.accuracyMETRIC(testLabels, test_pred_labels)
            dummyP, dummyR, f1_train = projectFunctions.f1METRIC(trainLabels, train_pred_labels)
            dummyP, dummyR, f1_test = projectFunctions.f1METRIC(testLabels, test_pred_labels)
        else:
            train_pred_labels = projectFunctions.prediction_Perceptron(trainMatrix, trainLabels, w)
            acc_train = projectFunctions.accuracyMETRIC(trainLabels, train_pred_labels)
            test_pred_labels = projectFunctions.prediction_Perceptron(testMatrix, testLabels, w)
            acc_test = projectFunctions.accuracyMETRIC(testLabels, test_pred_labels)
            dummyP, dummyR, f1_train = projectFunctions.f1METRIC(trainLabels, train_pred_labels)
            dummyP, dummyR, f1_test = projectFunctions.f1METRIC(testLabels, test_pred_labels)

        #for info ARRAY
        temp_list = []
        temp_list.append(shuffleTYPE)
        temp_list.append(e_ind+1)
        temp_list.append(acc_train)
        temp_list.append(f1_train)
        temp_list.append(acc_test)
        temp_list.append(f1_test)
        temp_list.append(w)
        #
        infoList.append(temp_list)
        '''
        if acc_train >= best_train_acc:
            best_train_acc = acc_train
            w_ATbestTRAINacc = w
            train_acc_ATbestTRAINacc = acc_train
            test_acc_ATbestTRAINacc = acc_test
            eval_acc_ATbestTRAINacc = acc_eval
            train_f1_ATbestTRAINacc = f1_train
            test_f1_ATbestTRAINacc = f1_test
            eval_f1_ATbestTRAINacc = f1_eval
        '''
        if f1_train >= best_f1_train:
            best_shuffle_type = shuffleTYPE
            best_epoch_index = e_ind
            best_acc_train = acc_train
            best_f1_train = f1_train
            best_acc_test = acc_test
            best_f1_test = f1_test
            best_w = w

    best_LIST = [best_shuffle_type,best_epoch_index,best_acc_train,best_f1_train,best_acc_test,best_f1_test,best_w]
    return best_LIST
